
Yallnix

3.75   A little thin.....


(At a quick check, it appeared that your two submissions were the same, so I only looked at one of them.)

Kernel.h
	I recommend starting with a bit or byte array to track pmem....     much easier to get right, and no need to invoke malloc so much

for the tty thingies, you might want an array instead of a special one for each

SetKernelBrk (and probably elsewhere): don't forget!  if you change a page->frame mapping in the MMU, flush its pte!

YalnixStuff:  In general, try to not to include the provided header files in your submission.

Scheduler.h:
	for the basic project, you are not likely to need to hash the pcbs

	createProcess: how do the page tables get created (and allocated)?

pipe: how does the blocking work


PageTable:
	// pagetable = malloc(sizeof(PTE *) * PAGE_TABLE_SIZE)
	// for each PTE *ptep: malloc(4);
	no... malloc sizeof(PTE)*PAGE_TABLE_SIZE.  the MMU expects an array of PTEs, not an array of PTE pointers.

	chunkValidityCheck:  i'm not sure what this does

PCB.h:
    // void *region1Base
    // void *region1Limit
    // void *KernelStackBase
    the above three are the same for all processes!

    however... where's the region1 page table?    the kernel stack ptes?

Kernel_TtyWrite (and the other blocking syscalls):
    it would be cleaner to have each of these calls handle blocking on their own.
    but if you're going to have common "block me" code within the kernel, that couldn't shouldn't be cvarwait, since there are no locks involved!

Kernel_PipeRead
	should block if the pipe is empty!

Kernel_PipeWrite
	what if a reader had been blocked?a


int Kernel_Acquire(int lock_id) {
    // (below has to be atomic -- ask Sean)
    ut will be.... interrupts are disabled in kernel mode

 Kernel_Release
	what if someone was blocked waiting for the lock?

KernelFork
	don't forget the parent and child return codes

KernelExit
	what if the parent was blocked waiting for this exit?


================


